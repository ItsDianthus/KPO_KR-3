# KPO_KR_3 

## Описание

Данный проект реализует архитектуру интернет-магазина с микросервисами для заказов и платежей, а также API Gateway для маршрутизации запросов. Все сервисы взаимодействуют асинхронно через Kafka, реализованы гарантии доставки и паттерны transactional outbox/inbox. Но главное ВСЁ РЕАЛЬНО РАБОТАЕТ! Я дебажила это оч долго. Прикрепляю пруфы в пдф формате

---

## Структура репозитория

```
KPO_KR_3/
├── api-gateway/           # API Gateway для роутинга запросов
│   ├── cmd/main.go        # Некая точка входа
│   └── Dockerfile         
├── orders-service/        # Микросервис заказов
│   ├── cmd/orders-service/main.go  # Точка входа
│   ├── internal/handler/   # HTTP-обработчики
│   ├── internal/model/     # Модели данных
│   ├── internal/repo/      # Работа с БД
│   ├── internal/worker/    # Outbox worker (паттерн transactional outbox)
│   ├── migrations/        
│   ├── Dockerfile         
│   └── go.mod             
├── payments-service/      # Микросервис платежей
│   ├── cmd/payments-service/main.go
│   ├── internal/handler/ # HTTP-обработчики
│   ├── internal/model/   # Модели данных
│   ├── internal/repo/    # Работа с БД
│   ├── internal/worker/   # Inbox/Outbox worker (паттерн transactional inbox/outbox)
│   ├── migrations/        
│   ├── Dockerfile         
│   └── go.mod             
└──docker-compose.yml     # Мстители-общий-сбор
└──swagger     # Там лежит опенапи спецификация
```

---

## Архитектура и соответствие требованиям

### 1. Микросервисыыы
- **API Gateway** — только маршрутизация запросов к сервисам
- **Orders Service** — создание заказа (асинхронно инициирует оплату), просмотр заказов, статус заказа
- **Payments Service** — создание счёта, пополнение, просмотр баланса, списание при оплате заказа

### 2. Асинхронное взаимодействие, всё как просили
- Используется Kafka для передачи событий между сервисами.
- В orders-service реализован паттерн **Transactional Outbox**: события о создании заказа сначала пишутся в outbox-таблицу, затем воркер отправляет их в Kafka
- В payments-service реализованы **Transactional Inbox и Outbox**: события из Kafka сохраняются в inbox-таблицу, обрабатываются атомарно, результат (успех/неуспех) пишется в outbox и отправляется в Kafka
- Все операции с балансом выполняются в транзакции, что обеспечивает атомарность и убивает коллизии

### 3. Семантика туда сюда
- Используется idempotency (inbox.processed), что обеспечивает at least once, а при корректной работе — exactly once.
- Баланс пользователя не может стать отрицательным при корректной работе.

### 4. Докеризация и запуск
- Каждый сервис упакован в Docker-контейнер (Dockerfile).
- Вся система разворачивается одной командой:
  ```sh
  docker-compose up --build
  ```
- Включены Kafka, Zookeeper, два Postgres, frontend, ну и сами сервисы (8 всего).

### 5. Миграции
- При старте сервисы автоматически применяют миграции для создания необходимых таблиц.

### 6. Тесты
- Для основных функций repo-слоя написаны unit-тесты с использованием sqlmock (покрытие 20-30%).

---

## Примеры API

- **Создать заказ:**
  `POST /orders?user_id=alice&amount=100`
- **Список заказов:**
  `GET /orders`
- **Статус заказа:**
  `GET /orders/{id}`
- **Создать счёт:**
  `POST /accounts?user_id=alice`
- **Пополнить счёт:**
  `POST /accounts/alice/topup?amount=100`
- **Посмотреть баланс:**
  `GET /accounts/alice/balance`

---

## Как работает сценарий оплаты заказа
1. Пользователь создаёт заказ через Orders Service
2. Событие о заказе попадает в outbox, затем воркер отправляет его в Kafka
3. Payments Service получает событие, списывает деньги с баланса пользователя (если хватает), пишет результат в outbox и отправляет обратно в Kafka
4. Статус заказа можно проверить через Orders Service

---

## Соответствие контрольной работе
- **Архитектура полностью соответствует ТЗ:** сервисы разделены, асинхронность реализована через Kafka, паттерны transactional outbox/inbox применены.
- **Гарантии доставки и атомарность обеспечены.**
- **Докеризация и миграции реализованы.**
- **Тесты и примеры API присутствуют.**
- **Даже фронтенд есть!!!**
- **Дока лежит в папке swagger**

---

## Запуск

1. Соберите и запустите все сервисы:
   ```sh
   docker-compose up --build
   ```
2. Используйте Postman, curl или Swagger для тестирования API через gateway (`localhost:8080`).

